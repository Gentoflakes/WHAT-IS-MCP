# MCP Servers and AI Agents: Complete Guide

## Table of Contents
1. [What are MCP Servers?](#what-are-mcp-servers)
2. [MCP vs RAG: Key Differences](#mcp-vs-rag-key-differences)
3. [Complete MCP Server Workflow](#complete-mcp-server-workflow)
4. [Local vs Remote Processing](#local-vs-remote-processing)
5. [When to Use MCP Servers](#when-to-use-mcp-servers)
6. [Alternative Ways to Build AI Agents](#alternative-ways-to-build-ai-agents)
7. [How Companies Implement AI Agents](#how-companies-implement-ai-agents)
8. [Privacy and Security Concerns](#privacy-and-security-concerns)
9. [Document Processing Challenges](#document-processing-challenges)
10. [Bot Detection Bypass Strategies](#bot-detection-bypass-strategies)
11. [Startup Ideas for Indian Market](#startup-ideas-for-indian-market)
12. [Agricultural Use Case for Farmers](#agricultural-use-case-for-farmers)

## What are MCP Servers? servers are external services that extend the capabilities of AI-powered development tools like Cursor. They act as specialized assistants that can perform specific tasks, access external data, or integrate with various services.

Concepts of MCP
​
Participants
MCP follows a client-server architecture where an MCP host — an AI application like Claude Code or Claude Desktop — establishes connections to one or more MCP servers. The MCP host accomplishes this by creating one MCP client for each MCP server. Each MCP client maintains a dedicated one-to-one connection with its corresponding MCP server.


The key participants in the MCP architecture are:
MCP Host: The AI application that coordinates and manages one or multiple MCP clients
MCP Client: A component that maintains a connection to an MCP server and obtains context from an MCP server for the MCP host to use
MCP Server: A program that provides context to MCP clients


For example: Visual Studio Code acts as an MCP host. When Visual Studio Code establishes a connection to an MCP server, such as the Sentry MCP server, the Visual Studio Code runtime instantiates an MCP client object that maintains the connection to the Sentry MCP server. When Visual Studio Code subsequently connects to another MCP server, such as the local filesystem server, the Visual Studio Code runtime instantiates an additional MCP client object to maintain this connection, hence maintaining a one-to-one relationship of MCP clients to MCP servers.


Note that MCP server refers to the program that serves context data, regardless of where it runs. MCP servers can execute locally or remotely. For example, when Claude Desktop launches the filesystem server, the server runs locally on the same machine because it uses the STDIO transport. This is commonly referred to as a “local” MCP server. The official Sentry MCP server runs on the Sentry platform, and uses the Streamable HTTP transport. This is commonly referred to as a “remote” MCP server.
​

- Layers
MCP consists of two layers:
1. Data layer: Defines the JSON-RPC based protocol for client-server communication, including lifecycle management, and core primitives, such as tools, resources, prompts and notifications.
2. Transport layer: Defines the communication mechanisms and channels that enable data exchange between clients and servers, including transport-specific connection establishment, message framing, and authorization.

Conceptually the data layer is the inner layer, while the transport layer is the outer layer.

- Data layer
The data layer implements a JSON-RPC 2.0 based exchange protocol that defines the message structure and semantics. This layer includes:

Lifecycle management: Handles connection initialization, capability negotiation, and connection termination between clients and servers

Server features: Enables servers to provide core functionality including tools for AI actions, resources for context data, and prompts for interaction templates from and to the client

Client features: Enables servers to ask the client to sample from the host LLM, elicit input from the user, and log messages to the client

Utility features: Supports additional capabilities like notifications for real-time updates and progress tracking for long-running operations
​
- Transport layer
The transport layer manages communication channels and authentication between clients and servers. It handles connection establishment, message framing, and secure communication between MCP participants.

MCP supports two transport mechanisms:

Stdio transport: Uses standard input/output streams for direct process communication between local processes on the same machine, providing optimal performance with no network overhead -> local MCP servers for filesystems. 

Streamable HTTP transport: Uses HTTP POST for client-to-server messages with optional Server-Sent Events for streaming capabilities. This transport enables remote server communication and supports standard HTTP authentication methods including bearer tokens, API keys, and custom headers. MCP recommends using OAuth to obtain authentication tokens.

The transport layer abstracts communication details from the protocol layer, enabling the same JSON-RPC 2.0 message format across all transport mechanisms.


MCP defines three core primitives that servers can expose:

Tools: Executable functions that AI applications can invoke to perform actions (e.g., file operations, API calls, database queries)
Resources: Data sources that provide contextual information to AI applications (e.g., file contents, database records, API responses)
Prompts: Reusable templates that help structure interactions with language models (e.g., system prompts, few-shot examples)


MCP clients will use the */list methods to discover available primitives. For example, a client can first list all available tools (tools/list) and then execute them. This design allows listings to be dynamic.

---------------------------------------------------

1. data layer : 

- initialisation : lifecycle management 

request : 

{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "initialize",
  "params": {
    "protocolVersion": "2025-06-18", -> to prevent version mismatch
    "capabilities": { -> shows the tools available
      "elicitation": {}
    },
    "clientInfo": { -> identification and versioning information for debugging and compatibility purposes.
      "name": "example-client",
      "version": "1.0.0"
    }
  }
}

response : 
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "protocolVersion": "2025-06-18",
    "capabilities": {
      "tools": {           -> The server supports the tools primitive AND can send tools/list_changed notifications when its tool list changes 
        "listChanged": true
      },
      "resources": {}       -> can handle resources/list and resources/read methods of server.
    },
    "serverInfo": {
      "name": "example-server",
      "version": "1.0.0"
    }
  }
}


-------------------------------------------------

- How this actually works to run AI application : 

1. During initialization, the AI application’s MCP client manager establishes connections to configured servers and stores their capabilities for later use. The application uses this information to determine which servers can provide specific types of functionality (tools, resources, prompts) and whether they support real-time updates.


2. tool confirmation : Now that the connection is established, the client can discover available tools by sending a tools/list request. This request is fundamental to MCP’s tool discovery mechanism — it allows clients to understand what tools are available on the server before attempting to use them.

request : 
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "tools/list"
}

response : 
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "tools": [
      {
        "name": "calculator_arithmetic",
        "title": "Calculator",
        "description": "Perform mathematical calculations including basic arithmetic, trigonometric functions, and algebraic operations",
        "inputSchema": {
          "type": "object",
          "properties": {
            "expression": {
              "type": "string",
              "description": "Mathematical expression to evaluate (e.g., '2 + 3 * 4', 'sin(30)', 'sqrt(16)')"
            }
          },
          "required": ["expression"]
        }
      },
      {
        "name": "weather_current",
        "title": "Weather Information",
        "description": "Get current weather information for any location worldwide",
        "inputSchema": {
          "type": "object",
          "properties": {
            "location": {
              "type": "string",
              "description": "City name, address, or coordinates (latitude,longitude)"
            },
            "units": {
              "type": "string",
              "enum": ["metric", "imperial", "kelvin"],
              "description": "Temperature units to use in response",
              "default": "metric"
            }
          },
          "required": ["location"]
        }
      }
    ]
  }
}

3. We then combine them into a unified tool registry that the language model can access. This allows the LLM to understand what actions it can perform and automatically generates the appropriate tool calls during conversations.

# Pseudo-code using MCP Python SDK patterns
available_tools = []
for session in app.mcp_server_sessions():
    tools_response = await session.list_tools()
    available_tools.extend(tools_response.tools)
conversation.register_available_tools(available_tools)


---------------------------------------------
all the communication at each step follows a strict protocal ie a template for communication -> a key MCP initiative which uses JSON-RPC Structure
--------------------------------------------


4. Tools execution :

request : 
{
  "jsonrpc": "2.0",
  "id": 3,
  "method": "tools/call",
  "params": {
    "name": "weather_current",
    "arguments": {
      "location": "San Francisco",
      "units": "imperial"
    }
  }
}

response : 
{
  "jsonrpc": "2.0",
  "id": 3,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "Current weather in San Francisco: 68°F, partly cloudy with light winds from the west at 8 mph. Humidity: 65%"
      }
    ]
  }
}

- This execution pattern allows AI applications to dynamically invoke server functionality and receive structured responses that can be integrated into conversations with language models.

- When the language model decides to use a tool during a conversation, the AI application intercepts the tool call, routes it to the appropriate MCP server, executes it, and returns the results back to the LLM as part of the conversation flow. This enables the LLM to access real-time data and perform actions in the external world.


5. Notifications : When the server’s available tools change—such as when new functionality becomes available, existing tools are modified, or tools become temporarily unavailable—the server can proactively notify connected clients

-> the key thing here is there is no notification :id here typically used in all HTTP calls.

- Upon receiving this notification, the client typically reacts by requesting the updated tool list. This creates a refresh cycle that keeps the client’s understanding of available tools current



---------------------------------------------USE CASE EXAMPLE---------------------------------------
### How Oracle's MCP Server Would Help You

If you install Oracle's MCP server in Cursor, here's what it would enable:

**Database Operations:**
- Schema exploration and query generation
- Data analysis and performance optimization
- Real-time database access and manipulation

**Development Workflow Enhancements:**
- Code generation for SQL queries and stored procedures
- Auto-generation of database documentation
- Testing and troubleshooting assistance

**Integration Benefits:**
- Real-time data access from your editor
- Schema validation against actual database structure
- Migration assistance and version control

## Why MCP Servers Are Needed

### Specialized Knowledge
- AI models have general knowledge but lack specific expertise about your particular systems
- MCP servers provide domain-specific capabilities (database, APIs, tools, etc.)

### Real-time Information
- AI models are trained on static data and can't access your current system state
- MCP servers can query live data, check current configurations, or access real-time information

### Security and Access Control
- MCP servers can handle authentication and authorization for sensitive systems
- They provide controlled access to production databases, APIs, or internal tools

### Tool Integration
- Connect to specific tools your organization uses (Jira, Salesforce, internal APIs)
- Access proprietary or custom systems that aren't publicly available


**Characteristics:**
- Real-time access to live systems
- Active operations (read/write/execute)
- Bidirectional communication (can modify data)
- Specialized capabilities (database queries, API calls, file operations)
- Stateful connections (maintains sessions)

**Example MCP Workflow:**
User: "Create a new employee record for John Doe"
↓
MCP Server: Connects to Oracle DB
↓
MCP Server: Generates INSERT statement
↓
MCP Server: Executes query against live database
↓
MCP Server: Returns confirmation with new employee ID
↓
User: Gets real confirmation with actual data


### What Runs Locally (in Your Machine):

1. **MCP Client** - The connector that talks to MCP servers
2. **Natural Language Processing** - Understanding user intent
3. **Response Formatting** - How results are displayed to you
4. **Session Management** - Keeping track of conversations
5. **UI/UX** - How you interact with the AI

### What Runs on MCP Server:

1. **Authentication & Authorization** - Secure access to external systems
2. **System-Specific Operations** - Database queries, API calls, file operations
3. **Data Processing** - Converting between formats, filtering results
4. **Connection Management** - Maintaining connections to external systems
5. **Business Logic** - Domain-specific operations and rules